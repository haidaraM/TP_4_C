\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}  
\usepackage[francais]{babel}   
\usepackage{fancyhdr}
\usepackage[top=2.5cm,bottom=2.5cm,left=2.5cm,right=2.5cm]{geometry}
\usepackage{lmodern}
\usepackage{listings}
\usepackage{color}
\usepackage{blindtext}
\usepackage[colorlinks=true,urlcolor=black,linkcolor=black]{hyperref}
\definecolor{grey}{rgb}{0.3,0.3,0.3}
\usepackage{graphicx}

\lstset{
language=C++,
basicstyle=\footnotesize\ttfamily,
numberstyle=\normalsize,
numbersep=7pt,
keywordstyle=\color{blue},
commentstyle=\color{grey}
}

\newcommand\Titre{TP4 Héritage, Polymorphisme}
\newcommand\Dater{Pour le 6 février 2015}
\newcommand{\Numbi}{B3425}
\newcommand{\Membres}{\textsc{Bai} Emilien,
\newline \textsc{Haidara} Mohamed}

\title{\Titre \newline \large Document de conception}
\author{Bin\^ome \Numbi{}: \Membres}
\date{\Dater}

\begin{document}

\pagestyle{fancy}
\renewcommand{\footrulewidth}{1pt}
\renewcommand{\headheight}{1cm}
\renewcommand{\contentsname}{Table des matières}



\lhead{\Membres}
\chead{\Titre}
\rhead{\Numbi}

\begin{center}
\begin{LARGE}
\begin{bfseries}

\vspace{1\baselineskip}

\underline{\Titre}
~\newline~\newline \begin{large} Document de conception\end{large}
\end{bfseries}
\end{LARGE}
\end{center}

\tableofcontents

\section*{Introduction}
Dans ce 4ème TP de C++ il nous était demandé d'implémenter un éditeur de formes géométriques : Cercle, Rectangle, Ligne, Polyligne et certaines opérations sur ces formes telles que la suppression, le déplacement, la sélection.
Les objectifs du TP étaient principalement de (re)voir des notions telles que:
\begin{itemize}
\item l'héritage
\item le polymorphisme
\item l'utilisation des design pattern (ou patrons de conception)
\item l'évaluation des performances d'un programme
\end{itemize}
Nous avons ainsi pu mettre en pratique les notions vues en cours. Dans ce document vous trouverez une explication détaillée de notre programme et des choix effectués. 


\section{Conception}
\subsection{Design Pattern}
Pour la réalisation du TP, nous avons combiné deux design patterns :
\begin{itemize}
\item \textbf{Pattern Singleton :} qui permet de restreindre l'instanciation d’une classe à un seul objet. Ainsi il n’y aura qu’une seule instance de l’application principale qui sera accessible par les autres classes qui en auront besoin directement notamment les commandes.
\item \textbf{Pattern Commande :} qui permet une séparation optimale du code initiateur de l’action du code de l’action elle-même. A Chaque commande, doit correspondre une classe qui possède deux méthodes publiques : une permettant d’exécuter la commande, l’autre d’annuler l’effet de la commande. 
\end{itemize}
De l’utilisation de ces deux commandes, a découlé une séparation de l’application en deux grosses parties :
\begin{itemize}
\item le \textbf{c\oe{}ur} de l’application appelée \textbf{Modele} avec une seule instance (geoEdit) composée de classes représentant les différentes formes géométriques.
\item la classe \textbf{Commande} avec ses descendants permettant de gérer les entrées et sorties. Cette modélisation permet dans le futur de réutiliser le c\oe{}ur de l’application avec une interface graphique par exemple
\end{itemize}

\subsection{Diagramme de Classes}
\begin{figure}[ht]
\begin{center}
\includegraphics*[scale = 0.5]{Tp4-Modele.png}
\end{center}
\caption{Modele}
\label{Coeur de l'application}
\end{figure}

\begin{figure}[Ht]
\begin{center}
\includegraphics[scale = 0.44]{Tp4-Commande.png}
\end{center}
\caption{Commande}
\label{Commande}
\end{figure}
~
\newline
\section{Spécifications}
Ici seront présentées les principales classes et leur méthodes et l’interaction qui se fait entre les classes.
\subsection{Modele et Commande}
La classe Modele, en tant que classe principale, peut être vue comme \textit{ une base de données} qui se charge de stocker toutes les formes et les commandes et fournis un certain nombre d’opérations aux commandes qui interagiront avec elles. 

Les formes sont stockées dans une MAP de type : \textit{ map<const string, Forme*> }. Ainsi une forme peut être retrouvée grâce à son nom.
\\A coté de cela, nous avons deux piles de pointeurs sur Commande permettant de gérer le UNDO et le REDO des commandes exécutées : 
\newline
\begin{itemize}
\item \textbf{Undo :} Cette méthode de la classe principale vérifie si la \textit{ pile cmdToUndo} est vide. Si ce n'est pas le cas, empile la dernière commande sur la deuxième \textit{pile cmdToRedo}, annule l'effet de la commande grâce à la méthode \textbf{UnExecute} de la classe commande et dépile \textit{cmdToUndo}.
\item \textbf{Redo :} Exécute les mêmes actions mais en dépilant sur	\textit{cmdToRedo} pour empiler sur \textit{cmdToUndo} et exécuter la méthode \textbf{Execute} sur la commande manipulée.
\end{itemize}

Tous les objets de la classe Commande partagent un \textbf{attribut static geoEdit} qui référence la classe principale Modele. Ainsi chaque objet Commande pourra modifier directement le Modele et ils partageront tous le même état de \textit{ la base de données.} Parmi les principales, méthodes fournies par le Modele, on peut citer :
\newline
\begin{itemize}
\item \textbf{void Ajouter(string name, Forme * forme ) :}

Cette méthode reçoit une Forme crée par une Commande et l’ajoute dans la map. Les vérifications sont effectuées par la commande qui s’assure qu’une autre forme ayant le même nom ne soit pas déjà présente à travers une méthode fournie par la classe principale.

\item \textbf{void Clear() :}

Supprime toutes les formes actuellement présentes dans la map. Mais avant de supprimer les formes, on réalise une copie au préalable. Ce mécanisme permet d’optimiser l’annulation de la commande CLEAR qui n’aura pas à récréer toutes les formes qui étaient déjà présentes dans la map.
\end{itemize}
Une autre optimisation a été au niveau de la commande LOAD plus précisément la classe \textit{ cmdLoad} qui permet de charger un ensemble de Forme à partir d'un fichier. Cette classe est composée d'autres commandes appelées \textit{cmdAjout} qui se chargeront de vérifier la syntaxe de toutes les lignes du fichier. Après avoir lu un fichier, on garde une indépendance totale vis à vis de celui-ci ce qui permet de pouvoir UNDO et REDO un LOAD sans lire encore une fois le fichier.

\subsection{Forme}
Cette \textbf{classe abstraite} constitue la classe de base dont va hériter toutes les formes géométrique.

\section{Tests}
L’application que nous avons réalisé a subi une batterie de Test décomposée en deux catégories :
\begin{itemize}
\item Les tests des fonctions “de base” sans conflit possible ou erreur de syntaxe : ces tests modélisent une utilisation sans erreur de l’application. Ils reprennent les fonctions telles qu’ajouter des formes ou des sélections, les déplacer, les supprimer, ou encore tester l’annulation d’une commande, sa reprise, l’enregistrement de la figure courante ainsi que le chargement d’une figure existante.
\item Les tests des fonctions “avancées” de l’application. Ces tests sont là pour vérifier que le programme ne plante pas en cas d’une utilisation différente de la syntaxe définie par le cahier des charges.
\end{itemize}
La liste des tests effectués est répertoriée dans le fichier tests/Liste\_des\_Tests.txt. Le script permettant d’effectuer la batterie de test mktest.sh . Ce script effectue à la suite tous les tests et réalise le bilan des résultats obtenus en répertoriant le nombre de tests passés, échoués ou mal formés.
\end{document}